package com.jugru.binaryTree;import java.util.*;public class BinaryTree {    private Node root;    public Node getRoot() {        return root;    }    public Node find(long value) {        return find(value, root);    }    private Node find(long value, Node node) {        if (node.getValue() == value) {            return node;        }        if (value > node.getValue()) {            if (node.getRight() != null) {                return find(value, node.getRight());            } else {                return null;            }        } else {            if (node.getLeft() != null) {                return find(value, node.getLeft());            } else {                return null;            }        }    }    public void add(long value) {        if (root == null) {            root = new Node(value, null);            return;        }        add(root, value);    }    private void add(Node parent, long value) {        if (value > parent.getValue()) {            //  попадаем в правую ветвь            // и если она пустая - создаем узел            if (parent.getRight() == null) {                Node right = new Node(value, parent);                parent.setRight(right);            } else {                // или идем рекурсивно глубже                add(parent.getRight(), value);            }        } else {            // попадаем в левую ветвь            if (parent.getLeft() == null) {                Node left = new Node(value, parent);                parent.setLeft(left);            } else {                // или снова идем рекурсивно глубже                add(parent.getLeft(), value);            }        }    }    /*     *  Чтобы найти следующее большее значение нужно сначала     *  поискать в ролительских нодах.     *     * */    public Long findNextLarger(long value) {        Node from = find(value);        if (from == null) {            return null;        }        // ищем значение больше в родительских нодах, начиная с ближайшего родителя        Node candidateFromParents = findNextLargerNodeInParent(from);        Node candidateFromChildren = from.getRight() != null ? findMinValueInChildNodes(from.getRight()) : null;        if (candidateFromChildren == null && candidateFromParents == null) {            return null;        }        if (candidateFromChildren == null || candidateFromParents == null) {            return candidateFromChildren != null ? candidateFromChildren.getValue() : candidateFromParents.getValue();        }        return candidateFromChildren.getValue() > candidateFromParents.getValue()                ? candidateFromParents.getValue()                : candidateFromChildren.getValue();    }    private Node findNextLargerNodeInParent(Node node) {        Node parent = node.getParent();        if (parent == null) {            return null;        }        if (node.getParent().getValue() > node.getValue()) {            return node.getParent();        }        return findNextLargerNodeInParent(node.getParent());    }    private Node findMinValueInChildNodes(Node node) {        if (node == null) {            return null;        }        if (node.getLeft() == null) {            return node;        } else {            return findMinValueInChildNodes(node.getLeft());        }    }    public List<Node> getAllNodes() {        List<Node> nodes = new ArrayList<>();        addAllChildNodes(this.getRoot(), nodes);        return nodes;    }    private void addAllChildNodes(Node node, List<Node> toFill) {        if (node == null) {            return;        }        toFill.add(node);        if (node.getLeft() != null) {            addAllChildNodes(node.getLeft(), toFill);        }        if (node.getRight() != null) {            addAllChildNodes(node.getRight(), toFill);        }    }    public List<Node> getBFSView() {        LinkedList<Node> queue = new LinkedList<>();        LinkedList<Node> result = new LinkedList<>();        queue.add(this.getRoot());        while (!queue.isEmpty()) {            Node first = queue.poll();            result.add(first);            if(first.getLeft() != null) {                queue.add(first.getLeft());            }            if(first.getRight() != null) {                queue.add(first.getRight());            }        }        return result;    }}