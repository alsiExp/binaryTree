package com.jugru.binaryTree;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.util.List;import java.util.stream.Collectors;import static com.jugru.binaryTree.BinaryTreeTestHelper.*;import static org.junit.jupiter.api.Assertions.*;public class BinaryTreeTest {    BinaryTree bt = null;    @BeforeEach    public void populate() {        bt = getFilledTree();    }    @Test    public void testCountNodes() {        assertEquals(23, bt.getAllNodes().size(), "Количество нод в тестовом дереве должно быть 23");    }    @Test    public void testFindValue() {        bt.getAllNodes()                .stream()                .map(Node::getValue)                .sorted()                .forEach(currentValueToFind -> {                    Node found = bt.find(currentValueToFind);                    assertNotNull(found, "Нода " + currentValueToFind + " существует в дереве и должна быть найдена");                    assertTrue(currentValueToFind == found.getValue(), "Ожидаемое значение = " + currentValueToFind + ", найденная нода = " + found);                });    }    @Test    public void testFindNextLargerValue() {        List<Long> values = bt.getAllNodes()                .stream()                .map(Node::getValue)                .sorted()                .collect(Collectors.toList());        for (int i = 0; i < values.size(); i++) {            long currentValueToFind = values.get(i);            Long nextLargerAwait = i == values.size() - 1 ? null : values.get(i + 1);            String errorMessage = "Для значения " + currentValueToFind                    + " ожмдаемое значение было " + nextLargerAwait + ", но было получено " + bt.findNextLarger(currentValueToFind) + ". Весь ряд " + values;            if (nextLargerAwait == null) {                assertNull(bt.findNextLarger(currentValueToFind), errorMessage);            }            assertEquals(nextLargerAwait, bt.findNextLarger(currentValueToFind), errorMessage);        }    }    @Test    public void testFindIfValueNotInTree() {        long notInTreeValue = 300;        assertNull(bt.find(notInTreeValue), "Значения " + notInTreeValue + " нет должно быть в дереве");        assertNull(bt.findNextLarger(notInTreeValue), "Значения " + notInTreeValue + " нет должно быть в дереве");    }    @Test    public void testGetBreadthFirstSearchView() {        long[] expected = {30L, 25L, 35L, 15L, 27L, 32L, 55L, 5L, 17L, 26L, 28L, 31L, 34L, 40L, 108L, 3L, 7L, 16L, 19L, 29L, 37L, 45L, 200L};        long [] fromTree = bt.getBFSView().stream()                .mapToLong(Node::getValue)                .toArray();        assertArrayEquals(expected, fromTree, "Ожидаемый и полученные значения представления поиска в ширину не совпадают");    }}